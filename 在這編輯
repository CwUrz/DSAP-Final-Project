
#include <vector>
#include <array>
#include <algorithm>
#include <queue>
#include <functional>
#include <climits>

class GamePlayer final : public Feis::IGamePlayer {
private:
    using Pos = Feis::CellPosition;
    struct Action{ 
        Feis::PlayerActionType type;
        Pos pos;
        // 方案 A：如果想用 emplace_back(type,pos)
        Action(Feis::PlayerActionType t, Pos p): type(t), pos(p) {}
    };

    std::vector<Action> actions_;
    size_t action_index_ = 0;
    bool initialized_  = false;

    static constexpr int H = Feis::GameManagerConfig::kBoardHeight;
    static constexpr int W = Feis::GameManagerConfig::kBoardWidth;
    static constexpr int G = Feis::GameManagerConfig::kGoalSize;
    static const std::array<Feis::Direction,4> dirs;

    inline int idx(Pos p) const { return p.row * W + p.col; }

    // 声明映射
    static Feis::PlayerActionType MachineType(Feis::Direction d);
    static Feis::PlayerActionType ConveyorType(Feis::Direction d);


    // helper: center entrances
    std::vector<std::pair<Pos,Pos>>
    GetCenterEntrances(const Feis::IGameInfo& info);

    // helper: scored mines (+collect cbmines)
    std::vector<Pos>
    GetScoredMines(const Feis::IGameInfo& info,
                   std::vector<Pos>& cbmines);

    // helper: BFS to first target, return (path, distance)
    std::pair<std::vector<Pos>,int>
    bfsToTargetWithDist(const Feis::IGameInfo& info,
                        const Pos& start,
                        std::function<bool(const Pos&)> isTarget);

    // helper: find best path for one mine
    struct PathResult {
        std::vector<Pos> path;
        Pos              target;
        Pos              centerCell;
    };
    PathResult
    findBestPathForMine(const Feis::IGameInfo& info,
                        const Pos& mine,
                        const std::vector<Pos>& builtConveyors,
                        const std::vector<std::pair<Pos,Pos>>& centerEntrances);

    // helper: build machine + conveyor from PathResult
    void buildMachineAndConveyor(const Feis::IGameInfo& info,
                                 const Pos& mine,
                                 const std::vector<Pos>& path,
                                 Pos target,
                                 Pos centerCell);

    // helper: process single mine
    void ProcessMine(const Feis::IGameInfo& info,
                     const Pos& mine,
                     std::vector<Pos>& builtConveyors,
                     const std::vector<std::pair<Pos,Pos>>& centerEntrances);

    // helper: process combiners (unchanged)
    void ProcessCombiners(const Feis::IGameInfo& info,
                          const std::vector<Pos>& cbmines,
                          std::vector<Pos>& builtConveyors,
                          const std::vector<std::pair<Pos,Pos>>& centerEntrances);

    // declarations for existing combiner helpers
    std::vector<Pos> bfsBetween(const Feis::IGameInfo& info,
                                const Pos& start,
                                const Pos& end);
    std::vector<Pos> getPathToAny(const Feis::IGameInfo& info,
                                  Pos& outEntrance,
                                  Pos& outCenter);

    // initialize calls the helpers
    void initialize(const Feis::IGameInfo &info) {
        auto centerEntrances = GetCenterEntrances(info);
        std::vector<Pos> cbmines;
        auto mines = GetScoredMines(info, cbmines);

        std::vector<Pos> builtConveyors;
        for (auto& m : mines) {
            ProcessMine(info, m, builtConveyors, centerEntrances);
        }

        ProcessCombiners(info, cbmines, builtConveyors, centerEntrances);
        initialized_ = true;
    }

public:
    Feis::PlayerAction GetNextAction(const Feis::IGameInfo &info) override {
        if (!initialized_) initialize(info);
        if (action_index_ < actions_.size()) {
            auto a = actions_[action_index_++];
            return { a.type, a.pos };
        }
        return { Feis::PlayerActionType::None, {0,0} };
    }
};

constexpr std::array<Feis::Direction,4> GamePlayer::dirs = {
    Feis::Direction::kLeft,
    Feis::Direction::kTop,
    Feis::Direction::kRight,
    Feis::Direction::kBottom
};


// 1) 实现映射
Feis::PlayerActionType GamePlayer::MachineType(Feis::Direction d) {
    switch (d) {
      case Feis::Direction::kTop:    return Feis::PlayerActionType::BuildTopOutMiningMachine;
      case Feis::Direction::kRight:  return Feis::PlayerActionType::BuildRightOutMiningMachine;
      case Feis::Direction::kBottom: return Feis::PlayerActionType::BuildBottomOutMiningMachine;
      case Feis::Direction::kLeft:   return Feis::PlayerActionType::BuildLeftOutMiningMachine;
    }
    return Feis::PlayerActionType::None;
}

Feis::PlayerActionType GamePlayer::ConveyorType(Feis::Direction d) {
    switch (d) {
      case Feis::Direction::kRight:  return Feis::PlayerActionType::BuildLeftToRightConveyor;
      case Feis::Direction::kBottom: return Feis::PlayerActionType::BuildTopToBottomConveyor;
      case Feis::Direction::kLeft:   return Feis::PlayerActionType::BuildRightToLeftConveyor;
      case Feis::Direction::kTop:    return Feis::PlayerActionType::BuildBottomToTopConveyor;
    }
    return Feis::PlayerActionType::None;
}

// ===== helper implementations =====

std::vector<std::pair<GamePlayer::Pos,GamePlayer::Pos>>
GamePlayer::GetCenterEntrances(const Feis::IGameInfo& info) {
    std::vector<std::pair<Pos,Pos>> centerEntrances;
    int top  = Feis::GameManager::CollectionCenterConfig::kTop;
    int left = Feis::GameManager::CollectionCenterConfig::kLeft;
    for (int r = top; r < top + G; ++r) {
        for (int c = left; c < left + G; ++c) {
            Pos cc{r,c};
            for (auto d : dirs) {
                Pos nb = Feis::GetNeighborCellPosition(cc, d);
                if (Feis::IsWithinBoard(nb) && !info.GetLayeredCell(nb).GetForeground()) {
                    centerEntrances.emplace_back(nb, cc);
                }
            }
        }
    }
    std::sort(centerEntrances.begin(), centerEntrances.end(),
        [](auto &a, auto &b){
            return a.first.row!=b.first.row
                ? a.first.row<b.first.row
                : a.first.col<b.first.col;
        });
    centerEntrances.erase(
        std::unique(centerEntrances.begin(), centerEntrances.end(),
            [](auto &a, auto &b){ return a.first==b.first; }),
        centerEntrances.end());
    return centerEntrances;
}

std::vector<GamePlayer::Pos>
GamePlayer::GetScoredMines(const Feis::IGameInfo& info,
                           std::vector<Pos>& cbmines) {
    int top  = Feis::GameManager::CollectionCenterConfig::kTop;
    int left = Feis::GameManager::CollectionCenterConfig::kLeft;
    Pos center{ top + G/2, left + G/2 };
    std::vector<Pos> mines;
    for (int r = 0; r < H; ++r) {
        for (int c = 0; c < W; ++c) {
            Pos p{r,c};
            if (auto bg = info.GetLayeredCell(p).GetBackground()) {
                if (auto num = dynamic_cast<const Feis::NumberCell*>(bg.get())) {
                    if (info.IsScoredProduct(num->GetNumber()))
                        mines.push_back(p);
                    else
                        cbmines.push_back(p);
                }
            }
        }
    }
    std::sort(mines.begin(), mines.end(), [&](const Pos&a, const Pos&b){
        int da = abs(a.row-center.row) + abs(a.col-center.col);
        int db = abs(b.row-center.row) + abs(b.col-center.col);
        return da < db;
    });
    std::sort(cbmines.begin(), cbmines.end(), [&](const Pos&a, const Pos&b){
        int da = abs(a.row-center.row) + abs(a.col-center.col);
        int db = abs(b.row-center.row) + abs(b.col-center.col);
        return da < db;
    });
    return mines;
}

std::pair<std::vector<GamePlayer::Pos>,int>
GamePlayer::bfsToTargetWithDist(
    const Feis::IGameInfo& info,
    const Pos& start,
    std::function<bool(const Pos&)> isTarget)
{
    std::vector<int> dist(H*W, -1);
    std::vector<Pos> prev(H*W);
    auto ix = [&](Pos p){ return p.row*W + p.col; };
    std::queue<Pos> q;
    dist[ix(start)] = 0;
    prev[ix(start)] = start;
    q.push(start);
    Pos found{-1,-1};
    while (!q.empty()) {
        Pos u = q.front(); q.pop();
        if (isTarget(u)) { found = u; break; }
        for (auto d : dirs) {
            Pos v = Feis::GetNeighborCellPosition(u,d);
            if (!Feis::IsWithinBoard(v) || dist[ix(v)]!=-1) continue;
            auto &cell = info.GetLayeredCell(v);
            if (cell.GetForeground() &&
                !dynamic_cast<const Feis::ConveyorCell*>(cell.GetForeground().get())) continue;
            if (cell.GetBackground() &&
                dynamic_cast<const Feis::NumberCell*>(cell.GetBackground().get())) continue;
            dist[ix(v)] = dist[ix(u)] + 1;
            prev[ix(v)] = u;
            q.push(v);
        }
    }
    if (found.row<0) return {{}, INT_MAX};
    std::vector<Pos> path;
    for (Pos cur=found; cur!=start; cur=prev[ix(cur)]) path.push_back(cur);
    std::reverse(path.begin(), path.end());
    return {path, dist[ix(found)]};
}

GamePlayer::PathResult
GamePlayer::findBestPathForMine(
    const Feis::IGameInfo& info,
    const Pos& mine,
    const std::vector<Pos>& builtConveyors,
    const std::vector<std::pair<Pos,Pos>>& centerEntrances)
{
    Pos centerCell{-1,-1};
    auto isConv = [&](const Pos&p){
        if (auto fg = info.GetLayeredCell(p).GetForeground())
            if (dynamic_cast<const Feis::ConveyorCell*>(fg.get())) return true;
        for (auto &bc : builtConveyors) if (bc==p) return true;
        return false;
    };
    auto isCent = [&](const Pos&p){
        for (auto const& [ent,cc]: centerEntrances) {
            if (ent==p) { centerCell=cc; return true; }
        }
        return false;
    };
    auto [pConv,dConv] = bfsToTargetWithDist(info, mine, isConv);
    auto [pCen ,dCen ] = bfsToTargetWithDist(info, mine, isCent);
    if (dConv <= dCen && !pConv.empty())
        return {pConv, pConv.back(), Pos{-1,-1}};
    if (!pCen.empty())
        return {pCen,  pCen.back(),  centerCell};
    return {{}, {}, {}};
}

void GamePlayer::buildMachineAndConveyor(
    const Feis::IGameInfo& info,
    const Pos& mine,
    const std::vector<Pos>& path,
    Pos target,
    Pos centerCell)
{
    // build machine
    Feis::Direction d0 = dirs[0];
    for (auto d: dirs) {
        if (Feis::GetNeighborCellPosition(mine,d)==path[0]) { d0=d; break; }
    }
    actions_.push_back(Action{ MachineType(d0), mine });
    // build conveyor
    for (size_t i=0; i<path.size(); ++i) {
        Pos src = path[i];
        Pos dst = (i+1<path.size() ? path[i+1] : centerCell);
        Feis::Direction di = dirs[0];
        for (auto d: dirs) {
            if (Feis::GetNeighborCellPosition(src,d)==dst) { di=d; break; }
        }
        actions_.push_back(Action{ ConveyorType(di), src });
    }
}

void GamePlayer::ProcessMine(
    const Feis::IGameInfo& info,
    const Pos& mine,
    std::vector<Pos>& builtConveyors,
    const std::vector<std::pair<Pos,Pos>>& centerEntrances)
{
    auto res = findBestPathForMine(info, mine, builtConveyors, centerEntrances);
    if (res.path.empty()) return;
    buildMachineAndConveyor(info, mine, res.path, res.target, res.centerCell);
    for (auto &p: res.path) builtConveyors.push_back(p);
}

// ProcessCombiners implementation unchanged, assumed provided elsewhere

// bfsBetween and getPathToAny assumed implemented elsewhere

